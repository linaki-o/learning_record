# 计算机网络和互联网

OSI 7层网络模型
TCP/IP 4层网络模型
计算机网络的核心是分层，应用层，传输层，网络层，数据链路层

每一层都有功能 其功能基于下面层的服务来实现

传输层协议
- tcp协议：可靠性高
- udp协议：适合实时传输

应用层：进程到进程 报文(message)

传输层：端到端 细分了服务，加强了服务，把Ip不可靠的服务，通过rpc的协议编程可靠的。端到端的，点到点，网络设备，P2P。E2E。 报文段(segment)

网络层：ip协议 数据报(datagram)

链路层：必须在数字链路层实现的。链路层提供的。中间要经过很多跳，网卡实现数据链路层。帧(frame)

物理层：把数字的信号。要不要发出去。光信号，无限的网卡。电磁波的形式。做一个相反的信号。bit

以前的只有传统的工作方式，分为两部分，路由之间相互交换路由信息。IP使用路由表，再从合适的路由。可以找到，从哪个端口放出去的。IP协议实体，根据到来的情况，查路由表，找到合适的端口放出去。

SDN方式：
- 控制平面：网络操作系统
- 数据平面：交换机

链路层的交换机 网络层的路由器

分组交换机有两种类型：
- 路由器 常用于网络核心
- 链路层交换机 常用于接入网


今天，宽带住宅接入有两种最流行的类型：数字用户线（Digital Subscriber Line,DSL）(电话线) 和 电缆(电视线) 光纤到户

以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。 网卡 MAC

computer也得跑server应用才会变成web服务器

linux上看TCP连接状态`netstat -napt`
`route -n` 命令查看当前系统的路由表

它目标地址和子网掩码都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，Gateway 即是路由器的 IP 地址。

ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

在 Linux 系统中，我们可以使用`arp -a`命令来查看 ARP 缓存的内容。

网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。

计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。(交换机的端口不具有MAC地址，那是怎么发到交换机的呢)

交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。

路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址

首先，我们需要根据路由表的网关列判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。

现在家里的路由器其实有了交换机的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。

网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会通过中断告诉操作系统这个网络包已经到达。 所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 **NAPI 机制**，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。

当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。

硬件中断处理函数
- 暂时屏蔽中断表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断
- 发起「软中断」，然后恢复刚才屏蔽的中断

内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。

会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。

## 什么是互联网


构成的角度：结点和边
- 主机结点
- 数据交换结点
- 接入的链路
- 骨干链路
- 协议

网络的网络

分布式的应用进程，以及为分布式应用进程提供通讯服务的基础设施

## 网络边缘

```
            |-------------------|
            |                   |
网络边缘-->  |      网络核心      | --> 网络边缘
    接入网   |                   |
            |-------------------|
```

端系统就是主机 路由器貌似不属于端系统

端系统协作的方式：
- C/S
- P2P(peer to peer) 每个结点既是服务器又是客户端

TCP服务：
- 握手
- 可靠的按顺序的传送数据
- 流量控制
- 拥塞控制

## 网络核心
交换结点与它们的链路构成的网络

交换方式
- 电路交换
    - 将带宽分成片
        - 频分(Frequency-division multiplexing)
        - 时分(Time-division multiplexing) TDM比FDM的优点：FDM需要复杂的模拟硬件来将信号转换为合适的频率
        - 波分(Wave-division multiplexing)
- **分组交换p33**
    - 单位存储-转发方式
    - 传输的数据被分为一个个分组
    - 完全占用两个结点之间的带宽 在结点处接收存储完毕后 与下一个结点继续 与上一个结点之间的链路就给别人去使用了 因为结点处要存储 所以延迟会比电路交换长
    - 还有排队时间
    - 统计多路复用
    - 数据报网络
    - 虚电路网络

**分组交换网中的时延、丢包和吞吐量p42**

**分组交换的习题很重要P8**

**传输延迟与传播延迟的类比p44**

**排队时延的例题p45**: https://gaia.cs.umass.edu/kurose_ross/interactive/qdelay.php

各种协议的概括p52

发送和接收不能分开算

## 接入网络和物理设备

bps(bits per second)

### 住宅接入 modem
将上网数据调制加载音频信号上 在电话线上传输 在局端将其中的数据解调处理 反之亦然

### DSL(digital subscriber line)

## Internet结构和ISP

端系统通过接入ISPs连接到互联网

接入ISPs相应的必须是互联的

每个接入ISP都连接到全局ISP

<img src="./1.png">


<img src="./2.png">

ICP 数据中心机房

接入方式：
- POP 上级和下级
- 对等接入
- IXP
- ICP自己部署专用网络

## 分组延时，丢失和吞吐量

四种分组延时：p43
- 节点处理时延
- 排队时延
    - 在输出链路上等待传输的时间

- 传输时延(与处理延时不同)
- 传播时延 距离近时可以忽略不计(物理上的)

hop

流量强度$\displaystyle \frac{La}{R}$ 1点的极限为无穷大

traceroute的原理p47
    - 计算端到端的时延

吞吐量：bps

## 协议层次与服务模型

5层因特网协议栈 

7层ISO OSI参考模型

<img src="3.png">
<img src="4.png">
<img src="6.png">
<img src="7.png">

交换PDU

两个哲学家交流问题

服务访问点：上层使用下层提供的服务通过层间的接口

SDU->PDU


## 历史

# 应用层

应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态

<img src="8.png">

## 原理
应用程序体系结构
- C/S
- P2P peer to peer

应用层协议定义的规则p81

应用协议只是应用层的一部分

分布式进程通信需要解决的问题：
- 进程标示和寻址问题
- 传输层和应用层提供服务的位置和形式
- 应用进程之间的报文交换，实现应用

层间接口必须携带的信息
- 要传输的报文SDU
- 谁传的
- 传给谁

socket封装了谁传的和传给谁的信息的本地标识 代表一个会话关系

有一个socket表

UDP socket 只代表本地IP和Port 不代表一个会话关系


应用需要传输层提供什么样的服务
- 数据丢失率
- 延迟
- 吞吐
- 安全性

实体：实现网络协议的软件模块或硬件模块 运行中

SSL： 安全套接字层 在应用层 在TCP上实现 私密性 数据完整性 端到端的鉴别 应用采用SSL库

## WEB与Http

无状态服务器
Http 是无状态的

非持久HTTP
- 最多只有一个对象在TCP连接上发送
- HTTP/1.0
持久HTTP(default)
- 多个对象在TCP连接上发送
- HTTP/1.1
    - HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。
- 流水线模式

先说明下安全和幂等的概念：
- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

HTTP 缓存有两种实现方式，
- 强制缓存  HTTP 响应头部（Response Header）`Cache-Control` 只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
- 协商缓存 某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源
    - 请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现
    - 请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段


HTTP/1.1 
- 无状态 cookie解决

**HTTP 的安全问题是怎么解决的，因为感觉有好多漏洞是可以利用的**: https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB

很有用的内容我的知识盲区

RSA 密钥交换算法: https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B
- 详细了一点 不过通常情况看上面一个的链接就够了
- 缺陷：不具备前向安全的性质, 服务端私钥失守就全完了

ECDHE 密钥协商算法: https://xiaolincoding.com/network/2_http/https_ecdhe.html#%E6%80%BB%E7%BB%93
- 离散对数 对数 + 取模 3个数很难推出一个数 a^i % p = b 很难推出i的值
- DH 算法 双方都有一个密钥
- static DH 算法，这个是已经被废弃了 服务端密钥不变 客户端动态生成 服务端密钥容易被破解 不具备前向安全性
- DHE 算法 E 全称是 ephemeral（临时性的） 双方密钥都是随机生成的
- ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。
- 各种优化 随机数等等

**假基站 中间人服务器问题** 真的是危险
- 中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。
- 如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

HTTPS 双向认证

HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持

HTTP各个版本的优缺点: https://xiaolincoding.com/network/2_http/http_interview.html#http-2-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96

如何优化Http/1.1(不是说Http/1.1的优点):
- 避免发送HTTP请求
    - 缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。
- 减少HTTP请求次数
    - 代理服务器帮你减少重定向次数 有一些重定向响应码
    - 合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求
    - 延迟发送请求
- 如何减少 HTTP 响应的数据大小
    - 无损压缩 `Accept-Encoding` `Content-Encoding` gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思
    - 有损压缩 可以通过 HTTP 请求头部中的 Accept 字段里的「 q 质量因子」，告诉服务器期望的资源质量。关于图片的压缩, 目前压缩比较高的是 Google 推出的 WebP 格式.关于音视频的压缩

如何优化Https:
- 性能损耗的两个环节
    - TLS 协议握手过程
    - 握手后的对称加密报文传输
- 硬件优化
    - HTTPS 协议是计算密集型，而不是 I/O 密集型 得优化CPU
- 软件升级 风险 花费较高
- 协议优化
    - 密钥交换算法优化 Nginx上可以配置
    - TLS 升级  TLS 1.2 升级成 TLS 1.3
- 证书优化
    - 证书传输优化
    - 证书验证优化 有意思
- 会话复用  都不具备前向安全性 有重放攻击的风险
    - Session ID 客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。 当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态
        - 服务器压力大
        - 负载均衡提供服务的，客户端再次连接不一定会命中上次访问过的服务器
    - Session Ticket 客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。 客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。
    - Pre-shared Key

HTTP/2的牛逼之处:
- 解决了HTTP/1.1的性能缺陷 从协议内部的优化
- 兼容性  只在应用层做了改变，还是基于 TCP 协议传输，应用层方面为了保持功能上的兼容，HTTP/2 把 HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。
- 头部压缩
    - 静态表编码
    - 动态表编码 不在静态表内的高频字符 内存内构建
- 二进制帧 Frame Header Frame Playload
- 并发传输
    - 多个 Stream 复用一条 TCP 连接，达到并发的效果
    - Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；Message 里包含一条或者多个 Frame
    - 不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ） 同一 Stream 内部的帧必须是严格有序的。
    - 同一个连接中的 Stream ID 是不能复用的，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 GOAWAY，用来关闭 TCP 连接。
    - 比 HTTP/1.1 通过 TCP 连接实现并发要牛逼的多
    - 可以根据资源的渲染顺序来设置 Stream 的优先级
- HTTP/2 队头阻塞问题：HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用
- 服务器主动推送资源 可以在发送html时同步发送css 不需要客户端再一次请求


HTTP/3的牛逼之处
- 解决了HTTP/2的问题
    - 队头阻塞
    - TCP 与 TLS 的握手时延迟 TCP与TLS的握手流程是分开的 很慢 拥塞控制
    - 网络迁移需要重新连接  TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。
- QUIC 协议
    - 还基于 UDP 协议在「应用层」实现了 QUIC 协议，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了
    - 而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。
    - HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。
- 连接迁移
- 动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。HTTP/3 的 QPACK解决了这个问题 QPACK Encoder Stream QPACK Decoder Stream同步动态表


TCP向上层提供的服务是没有边界限制的

用户服务器状态cookies p88

Web缓存 代理服务器
例题：p134 p9

代理服务器内容与original服务器中不同的问题:p92
- 条件GET方法
- 请求标头中加入if-modify_since的字段

## RPC

早期 QQ 大量使用 UDP

TCP基于字节流，没有任何边界, 有粘包问题: 夏洛特烦恼
所以http加了首部, 定义了协议

同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。


TCP与UDP这个传输层有头部吗：有TCP报文头部 https://xiaolincoding.com/network/1_base/what_happen_url.html#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-tcp

RPC（Remote Procedure Call）

现在电脑上装的各种联网软件，比如 xx管家，xx卫士，它们都作为客户端（Client）需要跟服务端（Server）建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。

很多软件同时支持多端，比如某度云盘，既要支持网页版，还要支持手机端和 PC 端，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。

与HTTP的区别
- 服务发现：HTTP是DNS服务 RPC有专门的中间服务Consul 或者 Etcd，甚至是 Redis，CoreDNS
- 底层连接 都基于TCP RPC会用连接池 而近来的一些网络库也会给HTTP加一个连接池
- 传输内容：HTTP是Header与body 而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，性能会好一点。HTTP/2 在前者的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP/2

## WebSocket

使用 HTTP 不断轮询是「伪」服务器推的形式

长轮询： HTTP 请求将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求

我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。


服务器推送（comet）

上面的方法当服务器需要主动推大量数据时不好用

WebSocket全双工基于TCP协议

浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信。如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的header 头 进行两次HTTP层面的握手

TCP的三次握手只需到传输层就够了

"WebSocket 是基于HTTP的新协议"，其实这并不对，因为WebSocket只有在建立连接时才用到了HTTP，升级完成之后就跟HTTP没有任何关系了。

数据格式也是Header+Body，这是因为 TCP 协议本身就是全双工，但直接使用纯裸TCP去传输数据，会有粘包的"问题"。为了解决这个问题，上层协议一般会用消息头+消息体的格式去重新包装要发的数据。

## FTP

RFC 959


控制命令的发送和数据的传输在不同的TCP上运行的

带内 带外

有状态的

## Email
<img src="9.png">
三个主要组成部分
- 用户代理
- 邮件服务器
- 简单邮件传输协议SMTP
    - 七位ASCII
    - PUSH
- 拉取邮件协议POP3(无状态 下载并删除 下载并保留) HTTP IMAP(远程目录维护 有状态)

“下载并删除”是指用户在一台机器上收取一个邮件之后，那么在其它的机器上将不能再次收取这个邮件。而“下载并保留”是在一台机器上接受这个邮件之后，用户在其他客户端也可以接受这个邮件。


报文格式：多媒体扩展MIME 编码方式Base64

## DNS

<img src="10.png">
<img src="12.png">
DNS是什么p102

53端口

DNS即使用UDP也使用TCP：https://www.cnblogs.com/wuyepeng/p/9835839.html

DNS记录和报文p107

实际上域名最后还有一个点，比如 www.server.com.，这个最后的一个点代表根域名。
也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com权威服务器。

树形结构

缓存

- DNS的任务p102
    - 主机名->Ip
    - 主机别名
    - 负载分配 
- DNS服务器类型p104
    - 根服务器
    - 顶级域服务器TLD
    - 权威服务
    - 本地服务器
- 查询方式p106
    - 迭代查询
    - 递归查询
- DNS记录和报文体p107
- 如何命名设备
    - 400个根名字服务器由13个不同的组织管理
    - 树状分层
- 如何完成名字到IP地址的转换
    - 分布式 zone
    - 一个zone内安排一个名字服务器 名字服务器要维护一个数据库
    - 数据库维护资源记录字段
        - Domain_name
        - Ttl: time to live
        - Class: IN(Internet)
        - Value: IP地址
        - Type(功能的类别)
            - 域名=>Ip地址
            - 别名转换
            - 邮件服务器
            - 划分子域
    - 递归查询 迭代查询 p106 迭代更好
- 报文格式
    - id号
- 如何维护一个域

## P2P应用

很重要的例题P2P与C/S的比较 p111


非结构化P2P
    - 集中式目录
        - 单点故障
        - 性能问题
        - 版权问题
    - 完全分布式（泛洪查询）
    - 混合体
    - 文件分发BitTorrent p115
        - BitMap

结构化(Distributed Hash Table)P2P

## CDN(Content Distribution Networks)

多媒体视频
    - CBR(constant bit rate)
    - VBR(variable bit rate)
    - 空间编码
    - 时间编码

Dynamic Adaptive Streaming over HTTP p116
    - 可以联想为b站视频播放方式


<img src="13.png">

CDN
    - enter deep
    - bring home
    
<img src="14.png">

CDN操作 p118
## TCP套接字编程

两个进程可以守护同一个端口

## 复习题 p131
答案：
https://blog.csdn.net/kieson_uabc/article/details/107071003?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107071003-blog-112135884.t0_layer_searchtargeting_s&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107071003-blog-112135884.t0_layer_searchtargeting_s&utm_relevant_index=1


1. 列出5种非专用的因特网应用及它们所使用的应用层协议
```
Web应用 HTTP
文件传输应用 FTP
email SMTP POP3 IMAP HTTP
远程终端访问 Telnet
因特网电话 SIP RTP
```
2. 网络体系结构与应用程序体系结构之间有什么区别？
```
```
3. 对两进程之间的通信会话而言，哪个进程是客户，哪个进程是服务器?
```
```
4. 对一个P2P文件共享应用，你同意“一个通信会话不存在客户端和服务器端的概念”的说法吗？为什么?
```
不同意 即使对于P2P应用来说每个端系统既是客户端也是服务器端 但是在一个通信会话中还是有客户端和服务器端之分的
```
5. 运行在一台主机上的一个进程，使用什么信息来标识运行在另一台主机上的进程?
```
IP地址与端口号
```
6. 假定你想尽快地处理从远程客户到服务器的事务，你将使用UDP还是TCP?为什么？
```
UDP 不需要建立连接 速度快
```
7. 你能设想一个既要求无数据丢失又高度时间敏感的应用程序吗?
```
```
8. 列出一个运输协议能够提供的4种宽泛类型的服务。对于每种服务类型，指出是UDP还是TCP （或这两种协议）提供这样的服务？
```
可靠数据传输：TCP
吞吐量：TCP和UDP都有
定时：TCP和UDP都有
安全性：TCP通过SSL加强提供完全服务
```
9. 前面讲过TCP能用SSL来强化，以提供进程到进程的安全性服务，包括加密。SSL运行在运输层还是应用层？如果某应用程序研制者想要用SSL来强化UDP,该研制者应当做些什么工作？
```
SSL运行在应用层，SSL不是与TCP和UDP在相同层次上的第三种因特网协议，而是对TCP的一种加强，研制者可以在发送主机中使用SSL加密该数据。
```

## 习题p133
答案：
https://blog.csdn.net/treblez/article/details/106237097
- P6
```
其中服务器与客户端都会假定连接没有关闭，除非对方传来的头文件包含" Connection:close"，不然连接将继续保持。客户端，服务器与代理都可以随时结束连接，而他们也应该有一套机制去重新搭建起连接，并保持正确性。

SSL
```

# 传输层

运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送

运输层协议只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层），反过来也是一样，但对有关这些报文在网络核心如何移动并不作任何规定

即使底层网络协议是不可靠的 运输协议也能为应用程序提供可靠的数据传输服务

进程到进程的数据交付和差错检查是两种**最低限度**的运输层服务，也是UDP所能提供的仅有的两种服务


## 概述
<img src="15.png">

## 多路复用和解复用

也就是将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务

在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字

**将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demultiplexing)。**

**在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用(nmhiplexing)**

UDP套接字由二元组标识 该二元组包含一个目的1P地址和一个目的端口号

TCP套接字是由一个四元组（源IP地址,源端口号，目的IP地址，目的端口号）来标识的。

多线程web服务器


## 无连接传输UDP
更适合用UDP的原因主要以下几点
- 关于发送什么数据以及何时发送的应用层控制更为精细
- 无须连接建立
- 无连接状态
- 分组首部开销小

检验和p151

## 可靠数据传输的原理

为分组添加序号来解决ACK或NAK分组受损的可能性

往返时延来解决丢包问题

流水线传输提高信道利用率
- 必须增加序号范围
- 协议的发送方和接收方两端也许不得不缓存多个分组
- 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组回退N步（Go Back N,GBN)和选择重传(Selective Repeat, SR)

RDT：可靠数据传输

UDT：不可靠数据传输

## 面向连接的运输：TCP

"TCP头部没说明数据大小吗, 不过好像也不需要因为有MSS以及首部大小" 但是它传输的数据是流的，所以不知道边界 所以要在HTTP协议上加强指定

TCP和UDP其实都是一个包一个包的传输，之所以说TCP是基于字节流而UDP是包是因为接收方的传输层的解释方式不同，想想操作socket的时候

UDP没有MSS的概念  UDP 的「包长度」目前略显冗余的

TCP 和 UDP 可以使用同一个端口 传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块, 会将报文发送给响应的程序

三次握手不包含应用层信息
三个状态：SYN-SENT SYN-RCVD ESTABLISHED

第三次握手是可以携带数据的，前两次握手是不可以携带数据的

建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。
- Socket：由 IP 地址和端口号组成
- 序列号：用来解决乱序问题等
- 窗口大小：用来做流量控制

为什么要三次握手(https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)：
- 阻止重复历史连接的初始化（主要原因）
- 同步双方初始序列号
- 避免资源浪费

有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是 客户端的IP数*客户端的端口数

既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
```
当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。

若没有MSS则当分片时TCP报文的头部只有一个
```

面向连接、可靠、基于字节流

该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中

三次握手：
- 客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷
- 会初始化发送缓存(MSS, MTU)

MSS在传输层分片的(不包含TCP头部) MTU在网络层（包含IP头部）

报文段结构p172

**往返时间的估计与超时p175**

可靠数据传输
- 超时间隔加倍
- 快速重传


TCP的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体

流量控制

**TCP连接管理**

**拥塞控制原理p188**

**TCP拥塞控制算法196**

**公平性**

# 网络层：数据平面
该数据平面功能决定到达路由器输入链路之一的数据报（即网络层的分组）如何转发到该路由器的输出链路之一

该控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。

**转发(forwarding)**是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。

**路由选择(routing)**是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程
主机和路由器是分离的

网络服务模型（network service model）p220

**分组交换机**是指一台通用分组交换设备，它根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。某些分组交换机称为链路层交换机（link layer switch ）（在第6章仔细学习），基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层（第2层）设备。其他分组交换机称为路由器（router）,基于网络层数据报中的首部字段值做岀转发决定


路由器工作原理
- 路由器结构
    - p221 输入端口查询转发表决定输出端口
- 输入端口处理和基于目的地转发
    - 用最长前缀匹配规则
- 交换分组方式
- 输出端口处理
    - 排队
    - 分组调度
- IPv4 IPv6 p232
    - **IPv4数据包分片**p234
    - **寻址 为无类别域间路由选择(Classless Inlerdomain Routing CIDR)p237**
    - 当一台主机发出一个目的地址为255. 255. 255. 255的数据报时，该报文会交付给同一个网络中的所有主机。路由器也会有选择地向邻近的子网转发该报文（虽然它们通常不这样做）。
- **获取主机地址：动态主机配置协议议（Dynamic Host Configuration, DHCP）p240**
- **网络地址转换(Network Address Translation ,NAT)p243**

- IPv6数据报格式p246
- IPv4 to IPv6建隧道
- **通用转发和SDN p249**

# 网络层: 控制平面

控制平面p261
- 每路由器控制

- 逻辑集中式控制

路由选择算法
- 集中式
    - 链路状态(Link State)算法 p264
        - Dijkstra
- 分布式
    - 距离向量(Distance-Vector, DV) p266
        - Bellman-Ford
        - 链路开销改变与链路故障问题：路由选择环路 p270
- 静态
- 动态
- 负载敏感
- 负载迟钝

因特网中自治系统内部的路由选择：OSPF p272
- 自治系统(Autonomous System)
- 自治系统内部路由选择协议
    - 开放最短路优先协议OSPF
- **ISP之间的路由选择：BGP(Broder Gateway protocol) p275**
    - 从邻居AS获得前缀的可达性信息
    - 确定到该前缀的最好的路由
    - 热土豆路由选择
    - 路由器选择算法

- **SDN控制平面p283**
    - 数据平面交换机 SDN控制器 网络控制应用程序
    - **SDN控制器的结构p285**
    - OpenFlow协议


