首先为了应试，其次为了更好的写c代码
# 错误信息

When you see a message like "*** stack smashing detected ***: terminated" in your program's output, it usually indicates a buffer overflow or stack corruption issue.

is generated by certain security mechanisms like **Stack Protector**, which is a feature in compilers like GCC.


# 数据类型

uint32_t类型当超出限制时自己就会取模了

uint64_t % 2^32 其实与 uint64_t强转uint32_t的作用是一样的 都是只保存最后32个bit

```c
int main() {
        uint32_t a = 4, b = 6;
        uint64_t c = b - a, d = a - b;
        printf("%ld %ld", c, d); // 设差值为x，则一个是x，一个是2^32 - x
        return 0;
}
```

sizeof是byte数量而不是元素数量

int dp[301][301] = {-1}; // 不能让每一个元素都是-1 只会让首元素

memset是以字节为单位的

对于unsigned与signed，要看你怎么解释它了
右移
```c
int NumberOf1(int n){
    printf("%d\n", n >> 31); // -1
    printf("%d\n", ((unsigned)n) >> 31); // 1
    return 0; 
}
int main(void) {
    NumberOf1(-1);
}
```
# 指针
对于指针来说 指针指向什么 那么对指针+1的跨度就是指向对象的大小
```c
int *p; // p + 1的话值是+4
int **pp; // pp + 1的话值是+8 因为指针大小为8个byte
```

不管你是1维数组，2维，3维，你的数据在内存中都是连续存放的，跨度都是一样

数组和指针不同，但数组会退化为指针, 不一样的是当我对指向数组的指针做+1时移动的是整个数组的长度，而对指向指针的指针移动的话移动的还是指针的大小
```c
void searchArray(int*** array) {
   printf("%p -> %p\n", array, array+1);
   return ; 
}
int main(void) {
    int array[2][2] = {
        {1,2},
        {3,4}
    };
    printf("%p -> %p\n", &array, (&array)+1); 
    searchArray(&array);
}
/*
0x7ffc27cb5e10 -> 0x7ffc27cb5e20
0x7ffc27cb5e10 -> 0x7ffc27cb5e18
*/
```
相关内容看efmcpp.md
```c
void searchArray(int (*array)[2][4]) { // 只有这样才能sizeof才能推导大小
    printf("%ld ", sizeof(*array)); // 32byte
    printf("%ld ", sizeof(**array)); // 16byte 对二维数组解引用一下就变一维数组了也挺有意思的 毕竟二维数组退化就是指向一维数组的指针int (*)[4]
    return ; 
}
```

# memcpy vs memmove

memcpy 面对overlapping regions时会undefined behavior 

The compiler can optimize and inline calls to standard C functions 编译器可以优化和内联标准C函数 这对于一些要求效率的应用来说还是挺重要的

一般这些函数都是极度的优化然后用汇编完成的，但还是得看应用场景

# Templating in C https://blog.pkh.me/p/20-templating-in-c.html

C macro实现
```cpp
#define DECLARE_FUNC(n)                                 \
static void func_##n(int##n##_t *p, int len, float k)   \
{                                                       \
    int i;                                              \
                                                        \
    for (i = 0; i < len; i++)                           \
        p[i] = p[i] * k;                                \
}

DECLARE_FUNC(8)
DECLARE_FUNC(16)
DECLARE_FUNC(32)
```

利用函数机制与编译器优化
```cpp
static inline int process_image(void *img, int width, int height, const int n)
{
    int x, y;

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            if      (n == 0) foo(img, x, y);
            else if (n == 1) bar(img, x, y);
            else             baz(img, x, y);
        }
    }
}

int process_image_foo(void *img, int width, int height)
{
    return process_image(img, width, height, 0);
}

int process_image_bar(void *img, int width, int height)
{
    return process_image(img, width, height, 1);
}

int process_image_baz(void *img, int width, int height)
{
    return process_image(img, width, height, 2);
}
```

结合
```cpp
static inline int process_image(void *img, int width, int height, const int n)
{
    int x, y;

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            if      (n == 0) foo(img, x, y);
            else if (n == 1) bar(img, x, y);
            else             baz(img, x, y);
        }
    }
}

#define DECLARE_PROCESS_IMAGE_FUNC(name, n)                 \
int process_image_##name(void *img, int width, int height)  \
{                                                           \
    return process_image(img, width, height, n);            \
}

DECLARE_PROCESS_IMAGE_FUNC(foo, 0)
DECLARE_PROCESS_IMAGE_FUNC(bar, 1)
DECLARE_PROCESS_IMAGE_FUNC(baz, 2)
```

External file实现
```cpp
#if defined(TEMPLATE_U16)

#    define RENAME(N)   N ## _u16
#    define TYPE        uint16_t
#    define SUM_TYPE    uint32_t
#    define XDIV(x, n)  (((x) + ((1<<(n))-1)) >> (n))

#elif defined(TEMPLATE_U32)

#    define RENAME(N)   N ## _u32
#    define TYPE        uint32_t
#    define SUM_TYPE    uint64_t
#    define XDIV(x, n)  (((x) + ((1<<(n))-1)) >> (n))

#elif defined(TEMPLATE_FLT)

#    define RENAME(N)   N ## _flt
#    define TYPE        float
#    define SUM_TYPE    float
#    define XDIV(x, n)  ((x) / (float)(1<<(n)))

#elif defined(TEMPLATE_DBL)

#    define RENAME(N)   N ## _dbl
#    define TYPE        double
#    define SUM_TYPE    double
#    define XDIV(x, n)  ((x) / (double)(1<<(n)))

#endif

TYPE RENAME(func)(const TYPE *p, int n)
{
    int i;
    SUM_TYPE sum = 0;

    for (i = 0; i < 1<<n; i++)
        sum += p[i];
    return XDIV(sum, n);
}

#undef RENAME
#undef TYPE
#undef SUM_TYPE
#undef XDIV
```

难点：指针, 数组，函数指针，运算符优先级

我发现通过看efmcpp居然让我更了解c语言了，看来还是看一下同等级同学的学习笔记对自己帮助很大
```c
/**
 * This is a brief example of typedef-ing and structs in C.
 * 一些结构体声明方法 正好是我平时不太会的
 */

typedef int Int; // int or Int

struct Person {
    char* name;
    Int age;
};

typedef struct Person APerson; // struct Person or APerson

typedef struct Animal {
    int legs;
} Animal; // struct Animal or Animal

typedef struct {
    int mpg;
} Car; // cannot use struct Car, can only use Car... the struct is anonymous

int main() {
    APerson person; // could use "struct Person person"
    person.name = "Phil";
    person.age = 10;

    Animal cat; // could use "struct Animal cat;"
    cat.legs = 4;

    Car car; // could not use "struct Car car;" because the struct was anonymous
    car.mpg = 30;
}
```

```c
// 有意思
struct foo;
typedef struct foo FILE;

extern int fputs(const char *, FILE *);
extern FILE *stdout;

int main(void)
{
    fputs("Hello, world!\n", stdout);
    return 0;
}
```
stdio.h 还做了什么

这里实际发生的事情是，stdio.h只是一个类型、函数和变量声明的列表，以及一些宏定义。C标准对编译器如何选择实现这些定义没有任何限制，但在实践中，像stdio.h这样的头文件几乎总是用稍微扩展的C方言实现的(它使用特定于编译器的扩展来完成无法在C中直接表示的事情，例如根据源程序中数组的长度添加缓冲区溢出检查代码)。

```c
#include <stdio.h>
int main(void)
{
        int arr[5];
        int *pa = arr;
        int (*pa2)[5] = &arr;

		printf("%p %p %p", arr, pa, pa2); // 虽然说三个值是一模一样的 但性质已经完全不同了
        printf("%p %p %p", arr+1, pa+1, pa2+1); // 前两个相同 后一个是加上数组的大小
        return 0;
}
```

# 数组
Note that the sizeof operator only works on things defined earlier in the same function. The compiler replaces it with some fixed constant number.

The information about the length of buffer is not actually stored anywhere in memory (unless we keep track of it separately) and cannot be programmatically obtained at run time from the array/pointer itself.
```c
#include <stdio.h>
int main(void)
{
        int arr[5];

        printf("%d %d", sizeof(arr), sizeof(*arr)); // 20, 4
        return 0;
}
```


这可能是数组退化的原因？ 所以一般要在加一个长度参数 真的解决了我一些问题
```cpp
/* broken.c - demonstrates a flaw */

#include <stdio.h>
#include <string.h>
#define NUM_ELEM(x) (sizeof (x) / sizeof (*(x)))

int sum( int input_array[] ){
  int sum_so_far = 0;
  int i;
  for( i = 0; i < NUM_ELEM(input_array); i++ ) // WON'T WORK -- input_array wasn't defined in this function.
  {
    sum_so_far += input_array[i];
  };
  return( sum_so_far );
}

int main(int argc, char *argv[])
{
  int left_array[] = { 1, 2, 3 };
  int right_array[] = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
  int the_sum = sum( left_array );
  printf( "the sum of left_array is: %d", the_sum );
  the_sum = sum( right_array );
  printf( "the sum of right_array is: %d", the_sum );

  return 0;
}
```

可以对type sizeof 也可以不加()

# Error handling 

C没有exception handling机制，所以需要程序员来处理
- errno
- 提前判断除0操作
- Signals
- setjmp：就是jump

# libraries
```c
#include <stdio.h>              /* for fprintf() and EOF */
#include <string.h>             /* for strchr() */
#include "getopt.h"             /* consistency check */

/* variables */
int opterr = 1;                 /* getopt prints errors if this is on */
int optind = 1;                 /* token pointer */
int optopt;                     /* option character passed back to user */
char *optarg;                   /* flag argument (or value) */

/* function */
/* return option character, EOF if no more or ? if problem.
	The arguments to the function:
	argc, argv - the arguments to the main() function. An argument of "--"
	stops the processing.
	opts - a string containing the valid option characters.
	an option character followed by a colon (:) indicates that
	the option has a required argument.
*/
int
getopt (int argc, char **argv, char *opts)
{
	static int sp = 1;            /* character index into current token */
	register char *cp;            /* pointer into current token */
	
	if (sp == 1)
	{
		/* check for more flag-like tokens */
		if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
			return EOF;
		else if (strcmp (argv[optind], "--") == 0)
		{
			optind++;
			return EOF;
		}
	}
	
	optopt = argv[optind][sp];
	
	if (optopt == ':' || (cp = strchr (opts, optopt)) == NULL)
	{
		if (opterr)
			fprintf (stderr, "%s: invalid option -- '%c'\n", argv[0], optopt);
		
		/* if no characters left in this token, move to next token */
		if (argv[optind][++sp] == '\0')
		{
			optind++;
			sp = 1;
		}
		
		return '?';
	}
	
	if (*++cp == ':')
	{
		/* if a value is expected, get it */
		if (argv[optind][sp + 1] != '\0')
			/* flag value is rest of current token */
			optarg = argv[optind++] + (sp + 1);
		else if (++optind >= argc)
		{
			if (opterr)
				fprintf (stderr, "%s: option requires an argument -- '%c'\n",
							argv[0], optopt);
			sp = 1;
			return '?';
		}
		else
	                /* flag value is next token */
		        optarg = argv[optind++];
		sp = 1;
	}
	else
	{
		/* set up to look at next char in token, next time */
		if (argv[optind][++sp] == '\0')
		{
			/* no more in current token, so setup next token */
			sp = 1;
			optind++;
		}
		optarg = 0;
	}
	return optopt;
} 
/* END OF FILE */
```
```h
#ifndef GETOPT_H
	#define GETOPT_H

	/* exported variables */
	extern int opterr, optind, optopt;
	extern char *optarg;

	/* exported function */
	int getopt(int, char **, char *);
#endif

/* END OF FILE */
```

头文件里放：
- struct, union, and enum declarations
- typedef declarations
- external function declarations
- global variable declarations

In Unix, directories of linked object files can be specified with the -L option to the cc command and individual libraries are specified with the -l (small ell) option. 

c的结构体是浅拷贝